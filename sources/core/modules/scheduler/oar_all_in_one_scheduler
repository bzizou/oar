#!/usr/bin/perl
#-d:DProf
#-d:NYTProf     --> nytprofhtml

use strict;
use warnings;
use DBI();
use OAR::IO;
use OAR::Modules::Judas qw(oar_debug oar_warn oar_error set_current_log_category);
use OAR::Conf qw(init_conf dump_conf get_conf is_conf get_conf_with_default_param);
use Data::Dumper;
use OAR::Tools;
use OAR::Modules::Hulot;
use OAR::Schedulers::Gantt;
use OAR::Schedulers::Quotas;

# Log category
set_current_log_category('scheduler');

my $SCHEDULER_NAME = "all_in_one_scheduler";

init_conf($ENV{OARCONFFILE});

##########################
# Fifo policy parameters #
##########################
my $SCHEDULER_FIFO_MAX_JOB = 1000;

#################################
# Fairsharing policy parameters #
#################################
# Avoid problems if there are too many waiting jobs
my $SCHEDULER_FAIRSHARING_MAX_JOB_PER_USER = get_conf_with_default_param("SCHEDULER_FAIRSHARING_MAX_JOB_PER_USER",30);
# number of seconds to consider for the fairsharing
my $SCHEDULER_FAIRSHARING_WINDOW_SIZE = get_conf_with_default_param("SCHEDULER_FAIRSHARING_WINDOW_SIZE",3600 * 30 * 24);
# specify the target percentages for project names (0 if not specified)
my $SCHEDULER_FAIRSHARING_PROJECT_TARGETS = { first => 75, default => 25 };
if (is_conf("SCHEDULER_FAIRSHARING_PROJECT_TARGETS")) {
    $SCHEDULER_FAIRSHARING_PROJECT_TARGETS = eval(get_conf("SCHEDULER_FAIRSHARING_PROJECT_TARGETS").";");
    if ($@) {
        oar_error("[$SCHEDULER_NAME] Syntax error in configuration file: SCHEDULER_FAIRSHARING_PROJECT_TARGETS\n");
        exit (1);
    }
}
# specify the target percentages for users (0 if not specified)
my $SCHEDULER_FAIRSHARING_USER_TARGETS = { oar => 100 };
if (is_conf("SCHEDULER_FAIRSHARING_USER_TARGETS")) {
    $SCHEDULER_FAIRSHARING_USER_TARGETS = eval(get_conf("SCHEDULER_FAIRSHARING_USER_TARGETS").";");
    if ($@) {
        oar_error("[$SCHEDULER_NAME] Syntax error in configuration file: SCHEDULER_FAIRSHARING_USER_TARGETS\n");
        exit (1);
    }
}
# weight given to each criteria
my $SCHEDULER_FAIRSHARING_COEF_PROJECT = get_conf_with_default_param("SCHEDULER_FAIRSHARING_COEF_PROJECT",0);
my $SCHEDULER_FAIRSHARING_COEF_USER = get_conf_with_default_param("SCHEDULER_FAIRSHARING_COEF_USER",2);
my  $SCHEDULER_FAIRSHARING_COEF_USER_ASK = get_conf_with_default_param("SCHEDULER_FAIRSHARING_COEF_USER_ASK",1);
my $karma_sum_time;
my $karma_users;
my $karma_projects;

##########
# Tokens #
##########
my $SCHEDULER_TOKEN_SCRIPTS = {};
if (is_conf("SCHEDULER_TOKEN_SCRIPTS")) {
    $SCHEDULER_TOKEN_SCRIPTS = eval(get_conf("SCHEDULER_TOKEN_SCRIPTS").";");
    if ($@) {
        oar_error("[$SCHEDULER_NAME] Syntax error in configuration file: SCHEDULER_TOKEN_SCRIPTS\n");
        exit (1);
    }
}

##########
# Quotas #
##########
my $QUOTA_FILE = "/etc/oar/scheduler_quotas.conf";
my ($quotas, $err) = OAR::Schedulers::Quotas::read_conf_file("$QUOTA_FILE");
if (defined($err)){
    oar_error("[$SCHEDULER_NAME] $err; QUOTA DISABLED\n");
}

##################
# Suspend/resume #
##################
my $JUST_BEFORE_RESUME_EXEC_FILE = get_conf("JUST_BEFORE_RESUME_EXEC_FILE");
my $SUSPEND_RESUME_SCRIPT_TIMEOUT = get_conf_with_default_param("SUSPEND_RESUME_SCRIPT_TIMEOUT", OAR::Tools::get_default_suspend_resume_script_timeout());
my $TAKTUK_CMD = get_conf("TAKTUK_CMD");
my $SUSPEND_RESUME_FILE = get_conf_with_default_param("SUSPEND_RESUME_FILE", OAR::Tools::get_default_suspend_resume_file());

###############################################################################

my $exit_code = 0;
my $base = OAR::IO::connect();
my $base_ro = OAR::IO::connect_ro();

my $SCHEDULER_RESOURCE_ORDER = get_conf("SCHEDULER_RESOURCE_ORDER");

my $CPUSET_PATH = get_conf("CPUSET_PATH");
my $CPUSET_FIELD = get_conf_with_default_param("JOB_RESOURCE_MANAGER_PROPERTY_DB_FIELD","cpuset");
my $SERVER_HOSTNAME = get_conf("SERVER_HOSTNAME");
my $SERVER_PORT = get_conf("SERVER_PORT");

my @SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE;
my $sched_available_suspended_resource_type_tmp = get_conf("SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE");
if (!defined($sched_available_suspended_resource_type_tmp)){
    push(@SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE, "default");
}else{
    @SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE = split(" ",$sched_available_suspended_resource_type_tmp);
}

# Look at resources that we must add for each job
my $SCHEDULER_RESOURCES_ALWAYS_ASSIGNED_TYPE = get_conf("SCHEDULER_RESOURCES_ALWAYS_ASSIGNED_TYPE");
my @Resources_to_always_add = ();

my $SCHEDULER_CONSTRAINTS_ITERATIONS = get_conf_with_default_param("SCHEDULER_CONSTRAINTS_ITERATIONS",4);
my $constraints = {};

# Do we log every scheduler's computation ?
my $SCHEDULER_LOG_DECISIONS = get_conf("SCHEDULER_LOG_DECISIONS");
if (defined($SCHEDULER_LOG_DECISIONS) and $SCHEDULER_LOG_DECISIONS ne "yes") { $SCHEDULER_LOG_DECISIONS = undef; }

# minimum of number of seconds between two jobs
my $SCHEDULER_JOB_SECURITY_TIME = get_conf_with_default_param("SCHEDULER_JOB_SECURITY_TIME", 60);

# Constant duration time of a besteffort job
my $SCHEDULER_BESTEFFORT_DURATION = get_conf_with_default_param("SCHEDULER_BESTEFFORT_DURATION)",5*60);


$SCHEDULER_BESTEFFORT_DURATION = $SCHEDULER_JOB_SECURITY_TIME if ($SCHEDULER_BESTEFFORT_DURATION < $SCHEDULER_JOB_SECURITY_TIME);

my $SCHEDULER_BESTEFFORT_KILL_DURATION_BEFORE_RESERVATION = get_conf_with_default_param("SCHEDULER_BESTEFFORT_KILL_DURATION_BEFORE_RESERVATION", 0);
$SCHEDULER_BESTEFFORT_KILL_DURATION_BEFORE_RESERVATION = $SCHEDULER_JOB_SECURITY_TIME if ($SCHEDULER_BESTEFFORT_KILL_DURATION_BEFORE_RESERVATION < $SCHEDULER_JOB_SECURITY_TIME);

$SCHEDULER_BESTEFFORT_DURATION = $SCHEDULER_BESTEFFORT_KILL_DURATION_BEFORE_RESERVATION if ($SCHEDULER_BESTEFFORT_DURATION < $SCHEDULER_BESTEFFORT_KILL_DURATION_BEFORE_RESERVATION);



my $OPENSSH_CMD = get_conf("OPENSSH_CMD");
$OPENSSH_CMD = OAR::Tools::get_default_openssh_cmd() if (!defined($OPENSSH_CMD));
if (is_conf("OAR_SSH_CONNECTION_TIMEOUT")){
    OAR::Tools::set_ssh_timeout(get_conf("OAR_SSH_CONNECTION_TIMEOUT"));
}
my $DEPLOY_HOSTNAME = get_conf_with_default_param("DEPLOY_HOSTNAME",$SERVER_HOSTNAME);
my $COSYSTEM_HOSTNAME = get_conf_with_default_param("COSYSTEM_HOSTNAME",$SERVER_HOSTNAME);

if (is_conf("OAR_RUNTIME_DIRECTORY")){
    OAR::Tools::set_default_oarexec_directory(get_conf("OAR_RUNTIME_DIRECTORY"));
}

#minimum of seconds to be considered like a hole in the gantt
my $SCHEDULER_GANTT_HOLE_MINIMUM_TIME = 0;
if (is_conf("SCHEDULER_GANTT_HOLE_MINIMUM_TIME")){
    $SCHEDULER_GANTT_HOLE_MINIMUM_TIME = get_conf("SCHEDULER_GANTT_HOLE_MINIMUM_TIME");
}

my $SCHEDULER_TIMEOUT = get_conf_with_default_param("SCHEDULER_TIMEOUT",10);

# timeout for validating reservation
my $RESERVATION_VALIDATION_TIMEOUT = 30;

# waiting time when a reservation has not all of its nodes
my $RESERVATION_WAITING_RESOURCES_TIMEOUT = get_conf_with_default_param("RESERVATION_WAITING_RESOURCES_TIMEOUT",300);

# global variables : initialized in init_scheduler function
my %BESTEFFORT_RESOURCE_OCCUPATION;

my $WALLTIME_CHANGE_ENABLED = uc(get_conf_with_default_param("WALLTIME_CHANGE_ENABLED","NO"));
# stock the job ids that where already send to almighty
my %jobs_to_launch_but_already_handled;

my $current_time_sec = 0;
my $current_time_sql = "0000-00-00 00:00:00";

###########################################################################################################
# Sub functions                                                                                           #
###########################################################################################################

# Detect if there are besteffort jobs to kill
# return 1 if there is at least 1 job to frag otherwise 0
sub check_jobs_to_kill(){
    oar_debug("[$SCHEDULER_NAME] Begin precessing of besteffort jobs to kill\n");
    my $return = 0;
    # Delete besteffort jobs in advance to let enough time to get back the nodes
    # in a good shape for the reservations
    my %nodes_for_jobs_to_launch = OAR::IO::get_gantt_resources_for_jobs_to_launch($base,$current_time_sec + $SCHEDULER_BESTEFFORT_KILL_DURATION_BEFORE_RESERVATION);
    my %fragged_jobs = ();
    foreach my $r (keys(%nodes_for_jobs_to_launch)){
        if (defined($BESTEFFORT_RESOURCE_OCCUPATION{$r})) {
            if (OAR::IO::is_timesharing_for_2_jobs($base, $nodes_for_jobs_to_launch{$r}, $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id})) {
                oar_debug("[$SCHEDULER_NAME] Resource $r is needed for job $nodes_for_jobs_to_launch{$r}, but besteffort job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id} can live, because timesharing compatible\n");
            } else {
                unless (defined($fragged_jobs{$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id}})) {
                    my $skip_kill = 0;
                    # Check if we must checkpoint the besteffort job
                    if ($BESTEFFORT_RESOURCE_OCCUPATION{$r}->{checkpoint} > 0){
                        my $checkpoint_first_date;
                        foreach my $e (OAR::IO::get_job_events($base, $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id})){
                            if ($e->{type} eq "CHECKPOINT"){
                                if ((!defined($checkpoint_first_date)) or ($checkpoint_first_date > $e->{date})){
                                    $checkpoint_first_date = $e->{date};
                                }
                            }
                        }
                        if ((!defined($checkpoint_first_date)) or ($current_time_sec <= ($checkpoint_first_date+$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{checkpoint}))){
                            oar_debug("[$SCHEDULER_NAME] Send checkpoint signal to job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id}\n");
                            # Retrieve node names used by the job
                            my @hosts = OAR::IO::get_job_current_hostnames($base,$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id});
                            my $types = OAR::IO::get_job_types_hash($base,$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id});
                            my $host_to_connect = $hosts[0];
                            if ((defined($types->{cosystem})) or ($#hosts < 0)){
                                $host_to_connect = $COSYSTEM_HOSTNAME;
                            }elsif (defined($types->{deploy})){
                                $host_to_connect = $DEPLOY_HOSTNAME;
                            }
                            OAR::IO::add_new_event($base,"CHECKPOINT",$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id},"User oar (metasched) requested a checkpoint on the job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id} on $host_to_connect");
                            $skip_kill = 1;
                            my $str_comment;
                            my @exit_codes;
                            # Timeout the ssh command
                            eval {
                                $SIG{ALRM} = sub { die "alarm\n" };
                                alarm(OAR::Tools::get_ssh_timeout());
                                @exit_codes = OAR::Tools::signal_oarexec($host_to_connect,$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id},"SIGUSR2",1,$base, $OPENSSH_CMD, '');
                                alarm(0);
                            };
                            if ($@){
                                if ($@ eq "alarm\n"){
                                    $str_comment = "[$SCHEDULER_NAME] Cannot contact $host_to_connect (timeout: ".OAR::Tools::get_ssh_timeout()." s), cannot send checkpoint signal to job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id}";
                                    oar_warn("$str_comment\n");
                                    OAR::IO::add_new_event($base,"CHECKPOINT_ERROR",$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id},$str_comment);
                                }else{
                                    $str_comment = "[$SCHEDULER_NAME] An unknown error occured while sending the checkpoint signal to job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id} on host $host_to_connect";
                                    oar_warn("$str_comment\n");
                                    OAR::IO::add_new_event($base,"CHECKPOINT_ERROR",$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id},$str_comment);
                                }
                            }else{
                                if ($exit_codes[0] == 0){
                                    $str_comment = "[$SCHEDULER_NAME] Job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id} on node $host_to_connect was notified to checkpoint";
                                    oar_debug("$str_comment\n");
                                    OAR::IO::add_new_event($base,"CHECKPOINT_SUCCESSFULL",$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id},$str_comment);
                                }else{
                                    $str_comment = "[$SCHEDULER_NAME] The kill command returned a bad exit code (@exit_codes) for the job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id} on the node $host_to_connect";
                                    oar_warn("$str_comment\n");
                                    OAR::IO::add_new_event($base,"CHECKPOINT_ERROR",$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id},$str_comment);
                                }
                            }
                        }else{
                            my $str_comment = "[$SCHEDULER_NAME] Checkpoint timeout for job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id} ($current_time_sec > ($checkpoint_first_date+$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{checkpoint})";
                            oar_debug("$str_comment\n");
                            OAR::IO::add_new_event($base,"CHECKPOINT_TIMEOUT",$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id},$str_comment);
                        }
                    }
                    if ($skip_kill == 0){
                        oar_debug("[$SCHEDULER_NAME] Resource $r need to be freed for job $nodes_for_jobs_to_launch{$r}: killing besteffort job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id}\n");
                        OAR::IO::add_new_event($base,"BESTEFFORT_KILL",$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id},"[$SCHEDULER_NAME] kill the besteffort job $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id}");
                        $base->begin_work();
                        OAR::IO::frag_job($base, $BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id});
                        $base->commit();
                    }
                    $fragged_jobs{$BESTEFFORT_RESOURCE_OCCUPATION{$r}->{job_id}} = 1;
                    $return = 1;
                }
            }
        }
    }
    oar_debug("[$SCHEDULER_NAME] End precessing of besteffort jobs to kill\n");
    return($return);
}

# Tell Almighty to run a job
sub notify_to_run_job($$){
    my ($base,
        $job_id) = @_;

    if (!defined($jobs_to_launch_but_already_handled{$job_id})){
        if (OAR::IO::is_job_desktop_computing($base, $job_id)){
            oar_debug("[$SCHEDULER_NAME] [$job_id] Desktop computing job, run is not handled here\n");
        }else{
            my $err = OAR::Tools::notify_tcp_socket($SERVER_HOSTNAME,$SERVER_PORT,"OARRUNJOB_$job_id");
            if (!defined($err)){
                $jobs_to_launch_but_already_handled{$job_id} = 1;
                oar_debug("[$SCHEDULER_NAME] Notify almighty to launch the job $job_id\n");
            }else{
                oar_warn("[$SCHEDULER_NAME] Not able to notify almighty to launch the job $job_id ($err)\n");
            }
        }
    }
}

# Prepare a job to be run by bipbip
sub prepare_job_to_be_launched($$$$$){
    my ($base,
        $job_id,
        $moldable_job_id,
        $job_submission_time,
        $resources_array_ref) = @_;

    my $running_date = $current_time_sec;
    if ($running_date < $job_submission_time){
        $running_date = $job_submission_time;
    }
    OAR::IO::set_running_date_arbitrary($base, $job_id, $running_date);
    OAR::IO::set_assigned_moldable_job($base, $job_id, $moldable_job_id);

    my $insert_from_file = get_conf_with_default_param("INSERTS_FROM_FILE", "no");
    if ($insert_from_file eq 'yes') {
        OAR::IO::add_resource_job_pairs_from_file($base, $moldable_job_id, $resources_array_ref);
    }else{
        OAR::IO::add_resource_job_pairs($base, $moldable_job_id, $resources_array_ref);
    }
    OAR::IO::set_job_state($base, $job_id, "toLaunch");
    notify_to_run_job($base, $job_id);
}


# Detect if there are jobs to launch
# return 1 if there is at least 1 job to launch otherwise 0
sub check_jobs_to_launch(){
    oar_debug("[$SCHEDULER_NAME] Begin processing of jobs to launch (start time <= $current_time_sql)\n");
    my $return_code = 0;
    my %jobs_to_launch = OAR::IO::get_gantt_jobs_to_launch($base,$current_time_sec);
    
    foreach my $i (keys(%jobs_to_launch)){
        oar_debug("[$SCHEDULER_NAME] [$i] set job state to toLaunch at $current_time_sql\n");
        # We must look at reservations to not go after the initial stop time
        my $mold = OAR::IO::get_current_moldable_job($base,$jobs_to_launch{$i}->[0]);
        my $job = OAR::IO::get_job($base,$i);
        if (($job->{reservation} eq "Scheduled") and ($job->{start_time} < $current_time_sec)){
            my $max_time = $mold->{moldable_walltime} - ($current_time_sec - $job->{start_time});
            OAR::IO::set_moldable_job_max_time($base,$jobs_to_launch{$i}->[0], $max_time);
            OAR::IO::set_gantt_job_startTime($base,$jobs_to_launch{$i}->[0],$current_time_sec);
            oar_warn("[$SCHEDULER_NAME] Reduce walltime of job $i to $max_time (was  $mold->{moldable_walltime})\n");
            OAR::IO::add_new_event($base,"REDUCE_RESERVATION_WALLTIME",$i,"Change walltime from $mold->{moldable_walltime} to $max_time");
            my $w = OAR::IO::duration_to_sql($max_time);                                                                            
            if ($job->{message} =~ s/W\=\d+\:\d+\:\d+/W\=$w/g){                                                                     
                OAR::IO::set_job_message($base,$i,$job->{message});                                                                  
            }
        }
        prepare_job_to_be_launched($base, $i, $jobs_to_launch{$i}->[0], $job->{submission_time}, $jobs_to_launch{$i}->[1]);
        $return_code = 1;
    }

    oar_debug("[$SCHEDULER_NAME] End processing of jobs to launch\n");
    return($return_code);
}

sub karma($$$$){
    my $karma_sum_time = shift;
    my $karma_projects = shift;
    my $karma_users = shift;
    my $j = shift;

    my $project_targets = (defined($SCHEDULER_FAIRSHARING_PROJECT_TARGETS->{$j->{project}}))?$SCHEDULER_FAIRSHARING_PROJECT_TARGETS->{$j->{project}}/100:0;
    my $user_targets = (defined($SCHEDULER_FAIRSHARING_USER_TARGETS->{$j->{job_user}}))?$SCHEDULER_FAIRSHARING_USER_TARGETS->{$j->{user}}/100:0;
    my $note = 0;
    $note = $SCHEDULER_FAIRSHARING_COEF_PROJECT * (($karma_projects->{$j->{project}}->{USED} / $karma_sum_time->{USED}) - $project_targets);
    $note += $SCHEDULER_FAIRSHARING_COEF_USER * (($karma_users->{$j->{job_user}}->{USED} / $karma_sum_time->{USED}) - $user_targets);
    $note += $SCHEDULER_FAIRSHARING_COEF_USER_ASK * (($karma_users->{$j->{job_user}}->{ASKED} / $karma_sum_time->{ASKED}) - $user_targets);

    return($note);
}

###########################################################################################################
# Handle walltime change requests                                                                              #
###########################################################################################################

sub process_walltime_change_requests($) {
    my $dbh = shift;
    OAR::IO::lock_table($dbh,['walltime_change']);
    my $jobs = OAR::IO::get_jobs_with_walltime_change($dbh);
    my $now = OAR::IO::get_date($dbh);
    my $Walltime_change_apply_time = eval(OAR::Conf::get_conf_with_default_param("WALLTIME_CHANGE_APPLY_TIME",0));
    my $Walltime_increment = eval(OAR::Conf::get_conf_with_default_param("WALLTIME_INCREMENT",0));
    foreach my $jobid (keys(%$jobs)) {
        my $job = $jobs->{$jobid};
        my $suspended = OAR::IO::get_job_suspended_sum_duration($dbh, $jobid, $now);
        my $fit = $job->{pending}; 
        if ($fit > 0) {
            my $apply_time = OAR::Walltime::get_conf($Walltime_change_apply_time, $job->{queue_name}, $job->{walltime} - $job->{granted}, 0);
            my $increment = OAR::Walltime::get_conf($Walltime_increment, $job->{queue_name}, $job->{walltime} - $job->{granted}, 0);
            oar_debug("[MetaSched] [$jobid] walltime change: pending=".$fit."s delay_next_jobs=".$job->{delay_next_jobs}." force=".$job->{force}." apply_time=${apply_time}s increment=${increment}s\n");
            if (not defined($job->{force}) or $job->{force} ne "YES") {
                my $delay = $job->{start_time} + $job->{walltime} + $suspended - $apply_time - $now;
                if ($apply_time > 0 and $delay > 0) {
                    oar_debug("[MetaSched] [$jobid] walltime change could apply in ${delay}s\n");
                    next; # next if activation time is set and activation date in the future
                }
                if ($increment > 0 and $increment < $fit) {
                    $fit = $increment;
                }
            }
            oar_debug("[MetaSched] [$jobid] walltime change try: $fit/".$job->{pending}."s\n");
            my $from = $job->{start_time} + $job->{walltime} + $suspended;
            my $to = $from + $fit;
            my $types = OAR::IO::get_job_types_hash($dbh,$jobid);
            if (exists($types->{inner})) {
                my $container_job = OAR::IO::get_running_job($dbh, $types->{inner});
                if (defined($container_job)) {
                    if ($container_job->{start_time} + $container_job->{moldable_walltime} < $to) {
                        $to = $container_job->{start_time} + $container_job->{moldable_walltime}; #container should never be suspended, makes no sense
                        oar_debug("[MetaSched] [$jobid] walltime change for inner job limited to the container's boundaries: ".($to - $from)."s\n");
                    }
                } else {
                    oar_debug("[MetaSched] [$jobid] walltime change for inner job but container is not found ?\n");
                }
            }
            $fit = OAR::IO::get_possible_job_end_time_in_interval($dbh, $from, $to, $job->{resources}, $SCHEDULER_JOB_SECURITY_TIME, $job->{delay_next_jobs}, $types, $job->{job_user}, $job->{job_name}) - $from;
            if ($fit <= 0) {
                oar_debug("[MetaSched] [$jobid] walltime cannot be changed for now (pending: ".OAR::IO::duration_to_sql_signed($job->{pending}).")\n");
                next;
            }
        } elsif ($fit < 0) {
            my $job_remaining_time = $job->{start_time} + $job->{walltime} + $suspended - $now;
            if ($job_remaining_time < -$fit) {
               $fit = -$job_remaining_time;
            }
        }

        my $new_walltime = $job->{walltime} + $fit;
        my $new_pending = $job->{pending} - $fit;

        my $message = "walltime changed: ".OAR::IO::duration_to_sql($new_walltime)." (granted: ".OAR::IO::duration_to_sql_signed($fit)."/pending: ".OAR::IO::duration_to_sql_signed($new_pending).(($job->{force} eq 'YES')?"/force":"").(($job->{delay_next_jobs} eq 'YES')?"/delay next jobs":"").")";
        oar_debug("[MetaSched] [$jobid] $message\n");
        OAR::IO::update_walltime_change_request($dbh, $jobid, $new_pending, ($new_pending == 0)?'NO':undef, ($new_pending == 0)?'NO':undef, $job->{granted} + $fit, ($job->{force} eq 'YES' and $fit > 0)?($job->{granted_with_force} + $fit):undef, ($job->{delay_next_jobs} eq 'YES' and $fit > 0)?($job->{granted_with_delaying_next_jobs} + $fit):undef);
        OAR::IO::change_walltime($dbh, $jobid, $new_walltime, $message);
    }
    OAR::IO::unlock_table($dbh);
}

if ($WALLTIME_CHANGE_ENABLED eq "YES") {
    process_walltime_change_requests($base);
}

###########################################################################################################
#Initialize Gantt tables with scheduled reservation jobs, Running jobs, toLaunch jobs and Launching jobs; #
###########################################################################################################

oar_debug("[$SCHEDULER_NAME] Starting Meta Scheduler\n");

# First get the resources which must be assigned to every jobs (SCHEDULER_RESOURCES_ALWAYS_ASSIGNED_TYPE configuration directive)
if (defined($SCHEDULER_RESOURCES_ALWAYS_ASSIGNED_TYPE)){
    my $tmp_result_state_resources = OAR::IO::get_specific_resource_states($base,$SCHEDULER_RESOURCES_ALWAYS_ASSIGNED_TYPE);
    if ($#{$tmp_result_state_resources->{"Suspected"}} >= 0){
        oar_warn("[$SCHEDULER_NAME] Some of the resources matching the SCHEDULER_RESOURCES_ALWAYS_ASSIGNED_TYPE configuration directive are Suspected. No job can be scheduled. We should abort the scheduling\n");
        # $aborted=1; #TODO: abort scheduling nicely?
    } elsif (defined($tmp_result_state_resources->{"Alive"})){
        @Resources_to_always_add = @{$tmp_result_state_resources->{"Alive"}};
        oar_debug("[$SCHEDULER_NAME] Resources to automatically add to all reservations: @Resources_to_always_add\n");
    }
}

# Take care of the currently (or nearly) running jobs
# Lock to prevent bipbip update in same time
$base->begin_work();

#calculate now date with no overlap with other jobs
my $previous_ref_time_sec = OAR::IO::get_gantt_date($base);
$current_time_sec = OAR::IO::get_date($base);
if ($current_time_sec < $previous_ref_time_sec){
    # The system is very fast!!!
    my $tmp_delta = $previous_ref_time_sec - $current_time_sec;
    if ($tmp_delta > 60){
        oar_error("[$SCHEDULER_NAME] The previous scheduler run was performed $tmp_delta seconds in the future. It is bad, the system clock of the DB server might have changed. This can results in wrong scheduling decisions.\n");
    }else{
        $current_time_sec = $previous_ref_time_sec;
        if ($tmp_delta > 1){
            # Avoid race condition that could increment too much the current time indefinitely
            oar_debug("[$SCHEDULER_NAME] The previous scheduler run was performed $tmp_delta seconds in the future. We have to wait, otherwise the scheduling decisions will be wrong\n");
            sleep($tmp_delta);
        }
    }
}
$current_time_sec++;
$current_time_sql = OAR::IO::local_to_sql($current_time_sec);

my ($Absent_resource_id_vec, undef) = OAR::IO::get_resource_ids_in_state($base,"Absent");

oar_debug("[$SCHEDULER_NAME] Retrieve information for already scheduled reservations from database before flush (keep assigned resources)\n");
my $reservation_already_there = OAR::IO::get_waiting_reservations_already_scheduled($base);
OAR::IO::gantt_flush_tables($base, $reservation_already_there, $SCHEDULER_LOG_DECISIONS);
OAR::IO::set_gantt_date($base,$current_time_sec);

#Init the gantt chart with all resources
oar_debug("[$SCHEDULER_NAME] Initialize the gantt structure\n");
my ($Max_resources, $All_resource_list_vec, $Only_default_type_resource_vec) = OAR::IO::get_vecs_resources($base);

my $gantt = {};
$gantt->{default}->{""}->{""}->{""} = OAR::Schedulers::Gantt::new($Max_resources, $SCHEDULER_GANTT_HOLE_MINIMUM_TIME);
OAR::Schedulers::Gantt::add_new_resources($gantt->{default}->{""}->{""}->{""}, $All_resource_list_vec);
my $quota_accounting_data = OAR::Schedulers::Quotas::new($SCHEDULER_JOB_SECURITY_TIME);

oar_debug("[$SCHEDULER_NAME] Begin processing of already handled reservations\n");
# Add already scheduled reservations into the gantt
foreach my $i (keys(%{$reservation_already_there})){
    my $gantt_name = "default";
    my $placeholder_name = "";
    my $allowed_name = "";
    my $timesharing_user = "";
    my $timesharing_name = "";
    my $vec = '';
    my $types = OAR::IO::get_job_types_hash($base,$i);
    my @type_list = sort(keys(%{$types}));
    my $job = $reservation_already_there->{$i};
    foreach my $r (@{$job->{resources}}){
        vec($vec, $r, 1) = 1;
    }

    if (defined($types->{container})){ # A container job cannot be placeholder or allowed or timesharing. 
        OAR::Schedulers::Gantt::manage_gantt_for_container($gantt, $types->{container}, $i, $job->{start_time}, $job->{walltime} + $SCHEDULER_JOB_SECURITY_TIME, $vec, $Max_resources, $All_resource_list_vec, $SCHEDULER_GANTT_HOLE_MINIMUM_TIME, "[$SCHEDULER_NAME] [$i]");

    } else {
        ($gantt_name, $placeholder_name, $timesharing_name, $timesharing_user) = 
            OAR::Schedulers::Gantt::manage_gantt_hierarchy($gantt, $job->{job_name}, $job->{job_user}, $types, undef, "[$SCHEDULER_NAME] [$i]");
    }

    #Fill all other gantts
    OAR::Schedulers::Gantt::fill_gantt_hierarchy($gantt, $job->{start_time}, $job->{walltime} + $SCHEDULER_JOB_SECURITY_TIME, $vec, $gantt_name ,$placeholder_name, $timesharing_name, $timesharing_user, "[$SCHEDULER_NAME] [$i]"); 
    OAR::Schedulers::Quotas::update_accounting_counters(
        $quota_accounting_data,
        unpack("%32b*",$vec & $Only_default_type_resource_vec),
        $job->{start_time},
        $job->{walltime},
        $job->{queue_name},
        $job->{project},
        \@type_list,
        $job->{job_user}
        );
}
oar_debug("[$SCHEDULER_NAME] End processing of already handled reservations\n");

oar_debug("[$SCHEDULER_NAME] Begin processing of current jobs\n");
sub handle_current_job($) {
    my $job = shift;
    my $gantt_name = "default";
    my $placeholder_name = "";
    my $allowed_name = "";
    my $timesharing_user = "";
    my $timesharing_name = "";
    my $i = $job->{job_id};

    return if ($job->{assigned_moldable_job} == 0);

    my $mold = OAR::IO::get_current_moldable_job($base,$job->{assigned_moldable_job});
    # if not passed in the job hash, retrieve the resource list for the job
    if (not defined($job->{resource_list_vec}) or not defined($job->{resource_list})){
        my @resource_list;
        ($job->{resource_list_vec}, @resource_list) = OAR::IO::get_job_current_resources($base, $job->{assigned_moldable_job},undef);
        $job->{resource_list} = \@resource_list; 
    }

    my $date ;
    if ($job->{start_time} == 0) {
        $date = $current_time_sec;
    }elsif ($job->{start_time} + $mold->{moldable_walltime} < $current_time_sec){
        $date = $current_time_sec - $mold->{moldable_walltime};
    }else{
        $date = $job->{start_time};
    }
    oar_debug("[$SCHEDULER_NAME] [$i] add job in the prediction table of the database\n");
    OAR::IO::add_gantt_scheduled_jobs($base,$job->{assigned_moldable_job},$date, $job->{resource_list});

    my @type_list = sort(keys(%{$job->{types}}));
    my $job_duration = $mold->{moldable_walltime};
    if ($job->{state} eq "Suspended"){
        # Remove resources of the type specified in SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE
        ($job->{resource_list_vec}) = OAR::IO::get_job_current_resources($base, $job->{assigned_moldable_job},\@SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE);
    }
    if ($job->{suspended} eq "YES"){
        # This job was suspended so we must recalculate the walltime
        $job_duration += OAR::IO::get_job_suspended_sum_duration($base,$job->{job_id},$current_time_sec);
    }

    if (defined($job->{types}->{container})){ # A container job cannot be placeholder or allowed or timesharing. 
        OAR::Schedulers::Gantt::manage_gantt_for_container($gantt, $job->{types}->{container}, $i, $date, $job_duration + $SCHEDULER_JOB_SECURITY_TIME, $job->{resource_list_vec}, $Max_resources, $All_resource_list_vec, $SCHEDULER_GANTT_HOLE_MINIMUM_TIME, "[$SCHEDULER_NAME] [$i]");

    } else {
        ($gantt_name, $placeholder_name, $timesharing_name, $timesharing_user) = 
        OAR::Schedulers::Gantt::manage_gantt_hierarchy($gantt, $job->{job_name}, $job->{job_user}, $job->{types}, undef, "[$SCHEDULER_NAME] [$i]");
    }

    #Fill all other gantts
    OAR::Schedulers::Gantt::fill_gantt_hierarchy($gantt, $date, $job_duration + $SCHEDULER_JOB_SECURITY_TIME, $job->{resource_list_vec}, $gantt_name ,$placeholder_name, $timesharing_name, $timesharing_user, "[$SCHEDULER_NAME] [$i]"); 
    OAR::Schedulers::Quotas::update_accounting_counters(
        $quota_accounting_data,
        unpack("%32b*",$job->{resource_list_vec} & $Only_default_type_resource_vec),
        $job->{start_time},
        $job_duration,
        $job->{queue_name},
        $job->{project},
        \@type_list,
        $job->{job_user}
    );
}
my @initial_jobs = OAR::IO::get_jobs_in_multiple_states($base, ["Running","toLaunch","Launching","Finishing","Suspended","Resuming"]);
my @inner_jobs;
my @besteffort_jobs;
while (@initial_jobs or @inner_jobs) {
    my $is_initial_job = @initial_jobs; # 0 = false if @initial_jobs is empty
    my $job = ($is_initial_job)?shift(@initial_jobs):shift(@inner_jobs);
    my $i = $job->{job_id};
    my @resource_list;
    ($job->{resource_list_vec}, @resource_list) = OAR::IO::get_job_current_resources($base, $job->{assigned_moldable_job},undef);
    $job->{resource_list} = \@resource_list;
    $job->{types} = OAR::IO::get_job_types_hash($base,$job->{job_id});
    oar_debug("[$SCHEDULER_NAME] [$i] job types: ".join(", ",keys(%{$job->{types}}))."\n");
    if (defined($job->{types}->{besteffort})){
        if (defined($job->{types}->{container})){
            oar_warn("[$SCHEDULER_NAME] [$i] job cannot be both besteffort and container, ignored\n");
        } else {
            oar_debug("[$SCHEDULER_NAME] [$i] besteffort job, ignored for now\n");
            #Stock information about besteffort jobs
            foreach my $r (@resource_list){
                $BESTEFFORT_RESOURCE_OCCUPATION{$r} = $job;
            }
            # besteffort jobs will only be added to gantt when managing the besteffort queue
            push(@besteffort_jobs, $job);
        }
    } elsif (defined($job->{types}->{inner}) and $is_initial_job){ # we are not yet in the @inner_jobs array
        # postpone handling of  inner jobs at the end, so that container gantts exists
        oar_debug("[$SCHEDULER_NAME] [$i] postpone inner job initialization after other jobs\n");
        push(@inner_jobs, $job);
    } else {
        handle_current_job($job);
    }
    if ($is_initial_job and not @initial_jobs and @inner_jobs){
        oar_debug("[$SCHEDULER_NAME] Now handling postponed inner jobs\n");
    }
}
$base->commit();
oar_debug("[$SCHEDULER_NAME] End processing of current jobs\n");

oar_debug("[$SCHEDULER_NAME] Begin processing of accepted reservations which do not have assigned resources yet\n");
foreach my $job (OAR::IO::get_waiting_reservation_jobs($base)){
    next if (defined($reservation_already_there->{$job->{job_id}}));

    my $gantt_name = "default";
    my $placeholder_name = "";
    my $allowed_name = "";
    my $timesharing_user = "";
    my $timesharing_name = "";
    my $i = $job->{job_id};


    my $job_descriptions = OAR::IO::get_resources_data_structure_current_job($base,$job->{job_id});
    # For reservation we take the first moldable job
    my $moldable = $job_descriptions->[0];

    # Get the list of resources where the reservation will be able to be launched
    my ($alive_resources_vector, undef) = OAR::IO::get_resource_ids_in_state($base,"Alive");
    #my ($tmp_veca, undef) = OAR::IO::get_resource_ids_in_state($base,"Absent");
    my $tmp_veca = $Absent_resource_id_vec;
    my ($tmp_vecs, undef) = OAR::IO::get_resource_ids_in_state($base,"Suspected");
    $alive_resources_vector |= $tmp_veca | $tmp_vecs;

    my $types = OAR::IO::get_job_types_hash($base,$i);
    my @type_list = sort(keys(%{$types}));
    if (defined($types->{inner})){
        $gantt_name = "container:$types>{inner}";
        if (not defined($gantt->{$gantt_name})){
            oar_debug("[$SCHEDULER_NAME] [$i] inner job, wants to use gantt: ($gantt_name,...), which does not exist. Skipped\n");
            OAR::IO::set_job_message($base,$i,"$gantt_name does not exist, skipped");
            OAR::IO::set_job_scheduler_info($base,$i,"$gantt_name does not exist, skipped");
            $gantt_name="default";
            next;
        }
    } elsif (defined($types->{constraints}) and not exists($constraints->{$types->{constraints}})) {
        my ($r, $max_constraint_duration) = OAR::Schedulers::Gantt::compute_constraints($types->{constraints}, $job->{start_time}, $SCHEDULER_CONSTRAINTS_ITERATIONS, "[$SCHEDULER_NAME] [$i]");
        $constraints->{$types->{constraints}} = $r;
        # Job cannot be scheduler if job duration does not fit in any constraint
        #if ($moldable->[1] + $SCHEDULER_JOB_SECURITY_TIME < $max_constraint_duration) {
        #    my $message = "job duration cannot fit in constraints. Skipped";
        #    oar_debug("[$SCHEDULER_NAME] [$i] $message\n");
        #    OAR::IO::set_job_message($base,$i,$message);
        #    OAR::IO::set_job_scheduler_info($base,$i,$message);
        #    next;
        #}
    }

    if (defined($types->{container})){ # A container job cannot be placeholder or allowed or timesharing. 
        oar_debug("[$SCHEDULER_NAME] [$i] job is ($gantt_name,,,) and is a container\n");
        # nothing more to do, Gantt for container will be created once the job is scheduled, below.
    } else {
        ($gantt_name, $placeholder_name, $allowed_name, $timesharing_name, $timesharing_user) =
            OAR::Schedulers::Gantt::manage_gantt_hierarchy($gantt, $job->{job_name}, $job->{job_user}, $types, $constraints, "[$SCHEDULER_NAME] [$i]");
    }

    my $free_resources_vec = OAR::Schedulers::Gantt::get_free_resources($gantt->{$gantt_name}->{$allowed_name}->{$timesharing_user}->{$timesharing_name}, 
                                                                        $job->{start_time},
                                                                        $moldable->[1] + $SCHEDULER_JOB_SECURITY_TIME,
                                                                   );
    $alive_resources_vector &= $free_resources_vec;
    
     # CM part
     if (is_conf("SCHEDULER_NODE_MANAGER_WAKE_UP_CMD")){
        $alive_resources_vector |= $free_resources_vec & OAR::IO::get_resources_that_can_be_waked_up($base,$job->{start_time} + $moldable->[1] + $SCHEDULER_JOB_SECURITY_TIME);
        $alive_resources_vector &= ~ ($All_resource_list_vec & OAR::IO::get_resources_that_will_be_out($base,$job->{start_time} + $moldable->[1] + $SCHEDULER_JOB_SECURITY_TIME));
     }
     # CM part
     else{
         $alive_resources_vector &= $free_resources_vec & $tmp_veca;
     }

    my ($dead_resources_vec, @dead_resources) = OAR::IO::get_resource_ids_in_state($base,"Dead");
    
    my $job_properties = "\'1\'";
    if ((defined($job->{properties})) and ($job->{properties} ne "")){
        $job_properties = $job->{properties};
    }

    my $resource_id_used_list_vector = '';
    my @tree_list;
    foreach my $m (@{$moldable->[0]}){
        my $tmp_properties = "\'1\'";
        if ((defined($m->{property})) and ($m->{property} ne "")){
            $tmp_properties = $m->{property};
        }
        my $tmp_tree;
        $tmp_tree = OAR::IO::get_possible_wanted_resources($base_ro,$alive_resources_vector,$resource_id_used_list_vector,\@dead_resources,"$job_properties AND $tmp_properties", $m->{resources}, "".$SCHEDULER_RESOURCE_ORDER);
        $tmp_tree = OAR::Schedulers::ResourceTree::delete_tree_nodes_with_not_enough_resources($tmp_tree);
        $tmp_tree = OAR::Schedulers::ResourceTree::delete_unnecessary_subtrees($tmp_tree);
        push(@tree_list, $tmp_tree);
        my @leafs = OAR::Schedulers::ResourceTree::get_tree_leafs($tmp_tree);
        foreach my $l (@leafs){
            vec($resource_id_used_list_vector, OAR::Schedulers::ResourceTree::get_current_resource_value($l), 1) = 1;
        }
    }
   
    my @resources;
    foreach my $t (@tree_list){
        foreach my $r (OAR::Schedulers::ResourceTree::get_tree_leafs($t)){
            push(@resources, OAR::Schedulers::ResourceTree::get_current_resource_value($r));
        }
    }

    if ($#resources >= 0){
        # We can schedule the job
        my $vec = '';
        foreach my $r (@resources){
            vec($vec, $r, 1) = 1;
        }

        # Create gantt for the new container
        if (defined($types->{container})){
            OAR::Schedulers::Gantt::manage_gantt_for_container($gantt, $types->{container}, $i, $job->{start_time}, $moldable->[1] + $SCHEDULER_JOB_SECURITY_TIME, $vec, $Max_resources, $All_resource_list_vec, $SCHEDULER_GANTT_HOLE_MINIMUM_TIME, "[$SCHEDULER_NAME] [$i]");
        }

        #Fill all other gantts
        OAR::Schedulers::Gantt::fill_gantt_hierarchy($gantt, $job->{start_time}, $moldable->[1] + $SCHEDULER_JOB_SECURITY_TIME, $vec, $gantt_name, $placeholder_name, $timesharing_name, $timesharing_user, "[$SCHEDULER_NAME] [$i]"); 
        OAR::Schedulers::Quotas::update_accounting_counters(
            $quota_accounting_data,
            unpack("%32b*",$vec & $Only_default_type_resource_vec),
            $job->{start_time},
            $moldable->[1],
            $job->{queue_name},
            $job->{project},
            \@type_list,
            $job->{job_user}
            );

        # Update database
        push(@resources, @Resources_to_always_add);
        oar_debug("[$SCHEDULER_NAME] [$i] add job in database\n");
        OAR::IO::add_gantt_scheduled_jobs($base,$moldable->[2],$job->{start_time},\@resources);
        #OAR::IO::set_job_message($base,$job->{job_id},"");
    }else{
        oar_warn("[$SCHEDULER_NAME] [$i] cannot find resources for reservation, did some resources become dead or get removed from database ?\n");
        OAR::IO::set_job_message($base,$job->{job_id},"Not able to find resources for this reservation");
    }
}
oar_debug("[$SCHEDULER_NAME] End processing of accepted reservations which do not have assigned resources yet\n");


###########################################################################################################
# End init scheduler                                                                                      #
###########################################################################################################

my %initial_time = (
                "sec" => $current_time_sec,
                "sql" => $current_time_sql
              );

my @queues = OAR::IO::get_active_queues($base);
my $queue_name;
my $policy;
while (@queues){
    my $queue = shift(@queues);
    $queue_name = $queue->[0];
    $policy = $queue->[1];
    if ($queue_name eq "besteffort"){
        if (@queues){
            oar_warn("[$SCHEDULER_NAME] Queue $queue_name: the besteffort queue must be the last one, ignoring ".join(" ", map {$_->[0]} @queues)."\n");
            @queues = ();
        }
        oar_debug("[$SCHEDULER_NAME] Queue $queue_name: begin processing of current besteffort jobs\n");
        while (@besteffort_jobs){
            handle_current_job(shift(@besteffort_jobs));
        }
        oar_debug("[$SCHEDULER_NAME] Queue $queue_name: end processing of current besteffort jobs\n");
    }
    my $waiting_jobs = OAR::IO::is_waiting_job_specific_queue_present($base,$queue_name);
    if ($waiting_jobs == 1){
###############################################################################
# Begin queue scheduler code 
###############################################################################
        my $timer_start_time = time();
        
        oar_debug("[$SCHEDULER_NAME] Queue $queue_name: starting scheduling at time $current_time_sec\n");
        
        # Token feature (see oar.conf)
        # Keep the track of the usage for each token
        my %Token_values;
        
        # Begining of the real scheduling
        
        # Get list of Alive resources
        my ($alive_resources_vector, undef) = OAR::IO::get_resource_ids_in_state($base,"Alive");
        
        # ENERGY SAVING: add fake occupations/holes from energy saving configuration 
        # CM part and Hulot part (wake up nodes in energy saving mode)
        if (is_conf("SCHEDULER_NODE_MANAGER_WAKE_UP_CMD") or (get_conf("ENERGY_SAVING_INTERNAL") eq "yes" and is_conf("ENERGY_SAVING_NODE_MANAGER_WAKE_UP_CMD"))){
            oar_debug("[$SCHEDULER_NAME] Queue $queue_name: start the energy saving phase\n");
            # Check the resources that can be waked_up or shut down
            my $upto_availability = OAR::IO::get_energy_saving_resources_availability($base, $current_time_sec);
            foreach my $t (keys(%{$upto_availability})){
                my $vec = '';
                foreach my $r (@{$upto_availability->{$t}}){
                    vec($alive_resources_vector, $r, 1) = 1;
                    vec($vec,$r,1) = 1;
                }
                #Fill all the gantts
                foreach my $c (keys(%{$gantt})){
                    foreach my $p (keys(%{$gantt->{$c}})){
                        foreach my $u (keys(%{$gantt->{$c}->{$p}})){
                            foreach my $n (keys(%{$gantt->{$c}->{$p}->{$u}})){
                                oar_debug("[$SCHEDULER_NAME] Queue $queue_name: add energy saving occupation in gantt ($c,$p,$u,$n)\n");
                                OAR::Schedulers::Gantt::set_occupation( $gantt->{$c}->{$p}->{$u}->{$n},
                                                         $t,
                                                         OAR::Schedulers::Gantt::get_infinity_value(),
                                                         $vec
                                                      );
                            }
                        }
                    }
                }
            }
            oar_debug("[$SCHEDULER_NAME] Queue $queue_name: end of the energy saving phase\n");
        }
        # CM part
         
        my ($Dead_resources_vec, @Dead_resources) = OAR::IO::get_resource_ids_in_state($base,"Dead");
        
        # Handle the different policies
        oar_debug("[$SCHEDULER_NAME] Queue $queue_name: start scheduling waiting batch jobs with policy $policy\n");
        my @jobs;
        if ($policy eq "fifo") {
            @jobs = OAR::IO::get_jobs_to_schedule($base,$queue_name,$SCHEDULER_FIFO_MAX_JOB);
        } elsif ($policy eq "fairsharing") {
            @jobs = OAR::IO::get_fairsharing_jobs_to_schedule($base,$queue_name,$SCHEDULER_FAIRSHARING_MAX_JOB_PER_USER);
            # Sort jobs depending on their previous usage (karma)
            $karma_sum_time = OAR::IO::get_sum_accounting_window($base,$queue_name,$current_time_sec - $SCHEDULER_FAIRSHARING_WINDOW_SIZE,$current_time_sec);
            $karma_sum_time->{ASKED} = 1 if (!defined($karma_sum_time->{ASKED}));
            $karma_sum_time->{USED} = 1 if (!defined($karma_sum_time->{USED}));
            
            $karma_projects = OAR::IO::get_sum_accounting_for_param($base,$queue_name,"accounting_project",$current_time_sec - $SCHEDULER_FAIRSHARING_WINDOW_SIZE,$current_time_sec);
            $karma_users = OAR::IO::get_sum_accounting_for_param($base,$queue_name,"accounting_user",$current_time_sec - $SCHEDULER_FAIRSHARING_WINDOW_SIZE,$current_time_sec);
            @jobs = sort({karma($karma_sum_time, $karma_projects, $karma_users, $a) <=> karma($karma_sum_time, $karma_projects, $karma_users, $b)} @jobs);
        } else {
            oar_debug("[$SCHEDULER_NAME] Queue $queue_name: unknown policy $policy\n");
            next;
        }
        oar_debug("[$SCHEDULER_NAME] Queue $queue_name: ".($#jobs + 1)." jobs for policy $policy\n");
        my $job_index = 0;
        while (($job_index <= $#jobs) and ((time() - $timer_start_time) < $SCHEDULER_TIMEOUT)){
            my $j = $jobs[$job_index];
            my $i = $j->{job_id};
            $job_index ++;
            oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] start scheduling".(($policy eq "fairsharing")?(" (Karma note = ".karma($karma_sum_time, $karma_projects, $karma_users, $j).")"):"")."\n");
            
            my $gantt_name = "default";
            my $placeholder_name = "";
            my $allowed_name = "";
            my $timesharing_user = "";
            my $timesharing_name = "";
            my $types = OAR::IO::get_job_types_hash($base,$i);
            my @type_list = sort(keys(%{$types}));

            # job time boundaries
            my $min_start_time = $current_time_sec;
            my $max_start_time = OAR::Schedulers::Gantt::get_infinity_value();
        
            if (defined($types->{postpone})) {
                my $postpone_time_sec = OAR::IO::sql_to_local($types->{postpone});
                if ($min_start_time < $postpone_time_sec) {
                    $min_start_time = $postpone_time_sec;
                    oar_debug("[$SCHEDULER_NAME] [$i] job is postponed to $types->{postpone}\n");
                }
            }

            if (defined($types->{expire})) {
                my $expire_time_sec = OAR::IO::sql_to_local($types->{expire});
                if ($min_start_time > $expire_time_sec) {
                    oar_debug("[$SCHEDULER_NAME] [$i] job will never run (expire=$types->{expire}), setting it to error\n");
                    OAR::IO::set_job_message($base, $i, "job canceled because expired");
                    OAR::IO::set_job_state($base, $i, "toError");
                    next;
                }
            }
            my $deadline_time_sec;
            if (defined($types->{deadline})) {
                $deadline_time_sec = OAR::IO::sql_to_local($types->{deadline});
                if ($min_start_time > $deadline_time_sec) {
                    oar_debug("[$SCHEDULER_NAME] [$i] job will never run (deadline=$types->{deadline}), setting it to error\n");
                    OAR::IO::set_job_message($base, $i, "job canceled because of its deadline");
                    OAR::IO::set_job_state($base, $i, "toError");
                    next;
                }
            }

            # Check the job dependencies 
            my $skip_job = 0;
            my $all_deps_already_ended = 1;
            foreach my $dep (OAR::IO::get_current_job_dependencies($base,$i)){
                oar_debug("[$SCHEDULER_NAME] [$i] manage dependency to job $dep->[0], min start shift: $dep->[1], max start shift: $dep->[2]\n");
                my $dep_job = OAR::IO::get_job($base,$dep->[0]);
                my $dep_job_start_time;
                my $dep_job_stop_time;
                my $dep_min_start_time = 0;
                my $dep_max_start_time = OAR::Schedulers::Gantt::get_infinity_value();
                if (($dep_job->{state} ne "Terminated") and ($dep_job->{state} ne "Error")){
                    $all_deps_already_ended = 0;
                    my $dep_moldable_job_id;
                    ($dep_job_start_time,$dep_moldable_job_id) = OAR::IO::get_gantt_job_start_time($base,$dep->[0]);
                    if (defined($dep_job_start_time)) {
                        $dep_job_stop_time = $dep_job_start_time + OAR::IO::get_current_moldable_job($base,$dep_moldable_job_id)->{moldable_walltime};
                    } else {
                        my $message = "dependency: job not scheduled because job $dep->[0] is not scheduled yet";
                        OAR::IO::set_job_message($base,$i,$message);
                        oar_debug("[$SCHEDULER_NAME] [$i] $message\n");
                        $skip_job = 1;
                        last;
                    }
                } else {
                    $dep_job_start_time = $dep_job->{start_time};
                    $dep_job_stop_time = $dep_job->{stop_time};
                }
                if (my ($boundary,$time) = $dep->[1] =~ /^([\[\]])([+-]?\d+)$/) {
                    if ($boundary eq '[') {
                        $dep_min_start_time = $dep_job_start_time + $time;
                    } elsif ($boundary eq ']') {
                        $dep_min_start_time = $dep_job_stop_time + $time;
                    }
                } else {
                    $dep_min_start_time = $dep_job_stop_time + 2 * $SCHEDULER_JOB_SECURITY_TIME;
                }
                if ($min_start_time < $dep_min_start_time){
                    oar_debug("[$SCHEDULER_NAME] [$i] dependency: new job scheduling min start time is $dep_min_start_time (was $min_start_time)\n");
                    $min_start_time = $dep_min_start_time;
                }
                if (my ($boundary,$time) = $dep->[2] =~ /^([\[\]])([+-]?\d+)$/) {
                    if ($boundary eq '[') {
                        $dep_max_start_time = $dep_job_start_time + $time;
                    } elsif ($boundary eq ']') {
                        $dep_max_start_time = $dep_job_stop_time + $time;
                    }
                } else {
                }
                if ($max_start_time > $dep_max_start_time){
                    oar_debug("[$SCHEDULER_NAME] [$i] dependency: new job scheduling max start time is $dep_max_start_time (was $max_start_time)\n");
                    $max_start_time = $dep_max_start_time;
                }
            }
            next if ($skip_job == 1);
            oar_debug("[$SCHEDULER_NAME] [$i] dependency: set job scheduling start time constraints [$min_start_time,$max_start_time]\n");
            if ($max_start_time < $min_start_time) {
                if ($all_deps_already_ended) {
                    # job dep won't change, killing job
                    my $message = "job cancelled because its dependency requirements will never be met";
                    oar_debug("[$SCHEDULER_NAME] [$i] $message\n");
                    OAR::IO::set_job_message($base, $i, $message);
                    OAR::IO::set_job_state($base, $i, "toError");
                } else {
                    oar_debug("[$SCHEDULER_NAME] [$i] job is not scheduled because its dependency requirement are currently not met\n");
                }
                next;
            }
        
            if (defined($types->{inner})) {
                $gantt_name = "container:$types->{inner}";
                if (not defined($gantt->{$gantt_name})){
                    oar_debug("[$SCHEDULER_NAME] [$i] inner job, wants to use gantt: ($gantt_name,...) which does not exist. Skipped\n");
                    OAR::IO::set_job_message($base,$i,"$gantt_name does not exist, skipped");
                    OAR::IO::set_job_scheduler_info($base,$i,"$gantt_name does not exist, skipped");
                    next;
                }
            } elsif (defined($types->{constraints}) and not exists($constraints->{$types->{constraints}})) {
                my ($r, $max_constraint_duration) = OAR::Schedulers::Gantt::compute_constraints($types->{constraints}, $min_start_time, $SCHEDULER_CONSTRAINTS_ITERATIONS, "[$SCHEDULER_NAME] [$i]");
                $constraints->{$types->{constraints}} = $r;
                # Job cannot be scheduler if job duration does not fit in any constraint
                #if ($duration < $max_constraint_duration) {
                #    my $message = "job duration cannot fit in constraints. Skipped";
                #    oar_debug("[$SCHEDULER_NAME] [$i] $message\n");
                #    OAR::IO::set_job_message($base,$i,$message);
                #    OAR::IO::set_job_scheduler_info($base,$i,$message);
                #    next;
                #}
            }
            if (defined($types->{container})){ # A container job cannot be placeholder or allowed or timesharing. 
                oar_debug("[$SCHEDULER_NAME] [$i] job is ($gantt_name,,,) and is a container\n");
                # nothing more to do, Gantt for container will be created once the job is scheduled, below.
            } else {
                ($gantt_name, $placeholder_name, $allowed_name, $timesharing_name, $timesharing_user) =
                    OAR::Schedulers::Gantt::manage_gantt_hierarchy($gantt, $j->{job_name}, $j->{job_user}, $types, $constraints, "[$SCHEDULER_NAME] [$i]");
            }
            if (defined($types->{token})){
                foreach my $t (keys(%{$types->{token}})){
                    next if ($skip_job == 1);
                    oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] checking token: $t ($types->{token}->{$t}).\n");
                    # Check if we must execute the corresponding script
                    if ((!defined($Token_values{$t})) and (defined($SCHEDULER_TOKEN_SCRIPTS->{$t}))){
                        oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] executing $SCHEDULER_TOKEN_SCRIPTS->{$t}\n");
                        if (open(TOKSCRIPT, "$SCHEDULER_TOKEN_SCRIPTS->{$t} |")){
                            my $num = <TOKSCRIPT>;
                            chop($num);
                            if ($num =~ /^\d+$/){
                                $Token_values{$t} = $num;
                                oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] $SCHEDULER_TOKEN_SCRIPTS->{$t} returned $num\n");
                            }else{
                                oar_warn("[$SCHEDULER_NAME] [$j->{job_id}] token script $SCHEDULER_TOKEN_SCRIPTS->{$t} did not return a number ($num).\n");
                            }
                            close(TOKSCRIPT);
                        }
                    }
                    if (defined($Token_values{$t})){
                        if ($Token_values{$t} < $types->{token}->{$t}){
                            oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] not enough tokens: $t ($Token_values{$t} < $types->{token}->{$t}).\n");
                            OAR::IO::set_job_message($base,$j->{job_id},"not enough tokens: $t ($Token_values{$t} < $types->{token}->{$t})");
                            #OAR::IO::set_job_scheduler_info($base,$j->{job_id},"No enough Token: $t ($Token_values{$t} < $types->{token}->{$t})");
                            $skip_job = 1;
                        }
                    }else{
                        oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] token value cannot be retrieved ($t).\n");
                        OAR::IO::set_job_message($base,$j->{job_id},"token value cannot be retrieved ($t)");
                        #OAR::IO::set_job_scheduler_info($base,$j->{job_id},"Token value cannot be retrieved ($t)");
                        $skip_job = 1;
                    }
                }
                next if ($skip_job == 1);
            }
            #OAR::Schedulers::Gantt::pretty_print($gantt_to_use);
            #oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] gantt data structure:\n".OAR::Schedulers::Gantt::pretty_print($gantt_to_use));
        
            my $job_properties = "\'1\'";
            if ((defined($j->{properties})) and ($j->{properties} ne "")){
                $job_properties = $j->{properties};
            }
            
            # Choose the moldable job to schedule
            my @moldable_results;
            my $job_descriptions = OAR::IO::get_resources_data_structure_current_job($base,$i);
            foreach my $moldable (@{$job_descriptions}){
                my $duration;
                if (defined($types->{besteffort})){
                    $duration = $SCHEDULER_BESTEFFORT_DURATION;
                }else{
                    $duration = $moldable->[1] + $SCHEDULER_JOB_SECURITY_TIME;
                }
        
                my @tree_list;
                foreach my $m (@{$moldable->[0]}){
                    my $tmp_properties = "\'1\'";
                    if ((defined($m->{property})) and ($m->{property} ne "")){
                        $tmp_properties = $m->{property};
                    }
                    my $tmp_tree = OAR::IO::get_possible_wanted_resources($base_ro,$alive_resources_vector,undef,\@Dead_resources,"$job_properties AND $tmp_properties", $m->{resources}, $SCHEDULER_RESOURCE_ORDER);
                    push(@tree_list, $tmp_tree);
                }
                my $gantt_timeout =  ($SCHEDULER_TIMEOUT - (time() - $timer_start_time)) / 4;
                oar_debug("[$SCHEDULER_NAME] [$i] find_first_hole in gantt ($gantt_name,$allowed_name,$timesharing_name,$timesharing_user) with a timeout of $gantt_timeout\n");
                my @hole = OAR::Schedulers::Gantt::find_first_hole(
                    $gantt->{$gantt_name}->{$allowed_name}->{$timesharing_name}->{$timesharing_user},
                    $min_start_time,
                    $duration,
                    \@tree_list,
                    $gantt_timeout,
                    $j->{queue_name},
                    $j->{project},
                    \@type_list,
                    $j->{job_user},
                    $quotas,
                    $quota_accounting_data,
                    $Only_default_type_resource_vec
                    );
                # Free memory
                foreach my $t (@tree_list){
                    OAR::Schedulers::ResourceTree::destroy($t);
                }
                my @resources;
                my $res_vec = '';
                foreach my $t (@{$hole[2]}){
                    $res_vec |= $t->[1];
                    push(@resources, @{$t->[2]});
                    OAR::Schedulers::ResourceTree::destroy($t->[0]);
                }
                push(@moldable_results, {
                                            resources => \@resources,
                                            resources_vec => $res_vec,
                                            start_time => $hole[0],
                                            duration => $duration,
                                            moldable_id => $moldable->[2],
                                            walltime => $moldable->[1],
                                            comment => $hole[1]
                                        });
            }
        
            # Choose moldable job which will finish the first
            my $index_to_choose = -1;
            my $best_stop_time;
            for (my $i=0; $i <= $#moldable_results; $i++){
                if ($#{$moldable_results[$i]->{resources}} >= 0){
                    my $tmp_stop_date = $moldable_results[$i]->{start_time} + $moldable_results[$i]->{duration};
                    if ((!defined($best_stop_time)) or ($best_stop_time > $tmp_stop_date)){
                        $best_stop_time = $tmp_stop_date;
                        $index_to_choose = $i;
                    }
                }
            }
            if ($index_to_choose >= 0){
                if (defined($deadline_time_sec) and $best_stop_time > $deadline_time_sec) {
                    oar_debug("[$SCHEDULER_NAME] [$i] not scheduling job because its deadline is not met: $best_stop_time > $deadline_time_sec\n");
                    next;
                }
                if ($moldable_results[$index_to_choose]->{start_time} > $max_start_time) {
                    oar_debug("[$SCHEDULER_NAME] [$i] not scheduling job because its max start time is exceeded: $moldable_results[$index_to_choose]->{start_time} > $max_start_time\n");
                    next;
                }
                # We can schedule the job
                oar_debug("[$SCHEDULER_NAME] [$i] job is successfully scheduled\n");
                # Create gantt for the new container
                if (defined($types->{container})){
                    OAR::Schedulers::Gantt::manage_gantt_for_container($gantt, $types->{container}, $i,  $moldable_results[$index_to_choose]->{start_time}, $moldable_results[$index_to_choose]->{duration}, $moldable_results[$index_to_choose]->{resources_vec}, $Max_resources, $All_resource_list_vec, $SCHEDULER_GANTT_HOLE_MINIMUM_TIME, "[$SCHEDULER_NAME] [$i]");
                }
        
                #Fill all other gantts
                OAR::Schedulers::Gantt::fill_gantt_hierarchy($gantt, $moldable_results[$index_to_choose]->{start_time}, $moldable_results[$index_to_choose]->{duration}, $moldable_results[$index_to_choose]->{resources_vec}, $gantt_name, $placeholder_name, $timesharing_name, $timesharing_user, "[$SCHEDULER_NAME] [$i]"); 
                OAR::Schedulers::Quotas::update_accounting_counters(
                    $quota_accounting_data,
                    unpack("%32b*",$moldable_results[$index_to_choose]->{resources_vec} & $Only_default_type_resource_vec),
                    $moldable_results[$index_to_choose]->{start_time},
                    $moldable_results[$index_to_choose]->{duration},
                    $j->{queue_name},
                    $j->{project},
                    \@type_list,
                    $j->{job_user}
                );
        
                #update database
                push(@{$moldable_results[$index_to_choose]->{resources}},@Resources_to_always_add);
                OAR::IO::add_gantt_scheduled_jobs($base,$moldable_results[$index_to_choose]->{moldable_id}, $moldable_results[$index_to_choose]->{start_time},$moldable_results[$index_to_choose]->{resources});
        
                # Feed message job field
                my $message = OAR::IO::format_job_message_text($j->{job_name},$#{$moldable_results[$index_to_choose]->{resources}}+1,$moldable_results[$index_to_choose]->{walltime},$j->{job_type},$j->{reservation},$j->{queue_name},$j->{project},\@type_list,join(",",(($policy eq "fairsharing")?("Karma=".sprintf("%.3f",karma($karma_sum_time, $karma_projects, $karma_users, $j))):""),"$moldable_results[$index_to_choose]->{comment}"));
                OAR::IO::set_job_message($base,$j->{job_id},$message);
                #OAR::IO::set_job_scheduler_info($base,$j->{job_id},"Karma = ".sprintf("%.3f",karma($karma_sum_time, $karma_projects, $karma_users, $j)));
        
                # Update Token values
                if (defined($types->{token}) and ($moldable_results[$index_to_choose]->{start_time} <= $current_time_sec)){
                    foreach my $t (keys(%{$types->{token}})){
                        $Token_values{$t} = $Token_values{$t} - $types->{token}->{$t};
                        oar_debug("[$SCHEDULER_NAME] Update TOKEN $t to $Token_values{$t}\n");
                    }
                }
        
                if ($moldable_results[$index_to_choose]->{start_time} <= $current_time_sec){
                    # Try to run the job now
                    if (get_conf_with_default_param("SCHEDULER_LAUNCHER_OPTIMIZATION", "yes") eq "yes") {
                        my $job_id_to_schedule = $j->{job_id};
                        my $moldable_job_id_to_schedule = $moldable_results[$index_to_choose]->{moldable_id};
                        my @job_resources_to_schedule = @{$moldable_results[$index_to_choose]->{resources}};
                        my $skip = "";
                        foreach my $r (@job_resources_to_schedule){
                            if (defined($BESTEFFORT_RESOURCE_OCCUPATION{$r})){
                                $skip = "a besteffort job needs to be killed first";
                                last;
                            }elsif(vec($Absent_resource_id_vec, $r, 1)){
                                $skip = "some nodes need to be booted first";
                            }
                        }
                        if ($skip eq ""){
                            oar_debug("[$SCHEDULER_NAME] [$job_id_to_schedule] early launch\n");
                            my $job = OAR::IO::get_job($base,$job_id_to_schedule);
                            prepare_job_to_be_launched($base, $job_id_to_schedule, $moldable_job_id_to_schedule, $job->{submission_time}, \@job_resources_to_schedule);
                        }else{
                            oar_debug("[$SCHEDULER_NAME] [$job_id_to_schedule] no early launch ($skip)\n");
                        }
                    }
                }
            }elsif ($moldable_results[0]->{comment} ne "TIMEOUT"){
                my $message = "not enough matching resources ($moldable_results[0]->{comment})";
                OAR::IO::set_job_message($base,$j->{job_id},$message);
                #OAR::IO::set_job_scheduler_info($base,$j->{job_id},$message);
                oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] $message\n");
            }
            oar_debug("[$SCHEDULER_NAME] [$i] end scheduling\n");
        }
        
        if ($job_index <= $#jobs){
            oar_debug("[$SCHEDULER_NAME] Warning: some jobs were not scheduled because the scheduler reached its timeout ($SCHEDULER_TIMEOUT s)\n");
        }
        
        oar_debug("[$SCHEDULER_NAME] Queue $queue_name: end of the batch jobs processing\n");

###############################################################################
# End queue scheduler code
###############################################################################

        if ($queue_name ne "besteffort") {
            oar_debug("[$SCHEDULER_NAME] Queue $queue_name: begin processing of reservations with missing resources\n");
    
            # See if there are reserved jobs to launch
            foreach my $job (OAR::IO::get_waiting_reservation_jobs_specific_queue($base,$queue_name)){
                my $job_descriptions = OAR::IO::get_resources_data_structure_current_job($base,$job->{job_id});
                my $moldable = $job_descriptions->[0];
            
                my $start = $job->{start_time};
                my $max = $moldable->[1];
                # Test if the job is in the past
                if ($current_time_sec > $start+$max ){
                    oar_warn("[$SCHEDULER_NAME] [$job->{job_id}] set job state to Error: reservation expired and couldn't be started\n");
                    OAR::IO::set_job_state($base, $job->{job_id}, "Error");
                    OAR::IO::set_job_message($base,$job->{job_id},"Reservation expired and couldn't be started.");
                }
                my @resa_alive_resources = OAR::IO::get_gantt_Alive_resources_for_job($base,$moldable->[2]);
                # test if the job is going to be launched and there is no Alive node
                if (($#resa_alive_resources < 0) && ($job->{start_time} <= $current_time_sec)){
                    oar_warn("[$SCHEDULER_NAME] [$job->{job_id}] reservation is waiting because no resource is present\n");
                    OAR::IO::set_gantt_job_startTime($base,$moldable->[2],$current_time_sec + 1);
                }elsif($job->{start_time} <= $current_time_sec){
                    my @resa_resources = OAR::IO::get_gantt_resources_for_job($base,$moldable->[2]);
                    if ($job->{start_time} + $RESERVATION_WAITING_RESOURCES_TIMEOUT > $current_time_sec){
                        if ($#resa_resources > $#resa_alive_resources){
                            # we have not the same number of nodes than in the query --> wait the specified timeout
                            oar_warn("[$SCHEDULER_NAME] [$job->{job_id}] reservation is waiting because not all resources are available yet\n");
                            OAR::IO::set_gantt_job_startTime($base,$moldable->[2],($current_time_sec + 1));
                        }
                    }else{
                        #Check if resources are in Alive state otherwise remove them, the job is going to be launched
                        foreach my $r (@resa_resources){
                            my $resource_info = OAR::IO::get_resource_info($base,$r);
                            if ($resource_info->{state} ne "Alive"){
                                oar_warn("[$SCHEDULER_NAME] [$job->{job_id}] drop resource $r of the reservation, because resource is $resource_info->{state})\n");
                                OAR::IO::remove_gantt_resource_job($base, $moldable->[2], $r);
                            }
                        }
                        if ($#resa_resources > $#resa_alive_resources){
                            OAR::IO::add_new_event($base,"SCHEDULER_REDUCE_NB_NODES_FOR_RESERVATION",$job->{job_id},"[$SCHEDULER_NAME] Reduce the number of resources for the job $job->{job_id}.");
                            my $n = $#resa_alive_resources + 1;
                            if ($job->{message} =~ s/R\=\d+/R\=$n/g) {
                                OAR::IO::set_job_message($base,$job->{job_id},$job->{message});
                            }
                        }
                    }
                }
            }
            oar_debug("[$SCHEDULER_NAME] Queue $queue_name: end processing of reservations with missing resources\n");
    
            oar_debug("[$SCHEDULER_NAME] Queue $queue_name: begin processing of new reservations\n");
            # Find jobs to check
            foreach my $job (OAR::IO::get_waiting_toSchedule_reservation_jobs_specific_queue($base,$queue_name)){
                my $gantt_name = "default";
                my $placeholder_name = "";
                my $allowed_name = "";
                my $timesharing_user = "";
                my $timesharing_name = "";
                my $i = $job->{job_id};
                my $types = OAR::IO::get_job_types_hash($base,$i);
                my @type_list = sort(keys(%{$types}));
                my $job_descriptions = OAR::IO::get_resources_data_structure_current_job($base,$job->{job_id});
                # It is a reservation, we take care only of the first moldable job
                my $moldable = $job_descriptions->[0];
                my $duration = $moldable->[1];
    
                #look if reservation is too old
                if ($current_time_sec >= ($job->{start_time} + $duration)){
                    oar_warn("[$SCHEDULER_NAME] [$i] canceling job: reservation is too old\n");
                    OAR::IO::set_job_message($base, $job->{job_id}, "Reservation too old");
                    OAR::IO::set_job_state($base, $job->{job_id}, "toError");
                }else{
                    if ($job->{start_time} < $current_time_sec){
                        $job->{start_time} = $current_time_sec;
                        #OAR::IO::set_running_date_arbitrary($base,$job->{job_id},$current_time_sql);
                    }
                    
                    # Get the list of resources where the reservation will be able to be launched
                    my ($alive_resources_vector, undef) = OAR::IO::get_resource_ids_in_state($base,"Alive");
                    #my ($tmp_veca, undef) = OAR::IO::get_resource_ids_in_state($base,"Absent");
                    my $tmp_veca = $Absent_resource_id_vec;
                    my ($tmp_vecs, undef) = OAR::IO::get_resource_ids_in_state($base,"Suspected");
                    $alive_resources_vector |= $tmp_veca | $tmp_vecs;
                    if (defined($types->{inner})) {
                        $gantt_name = "container:$types->{inner}";
                        if (not defined($gantt->{$gantt_name})){
                            oar_debug("[$SCHEDULER_NAME] [$i] inner job, want to use gantt: ($gantt_name,...) which does not exist. Skipped\n");
                            OAR::IO::set_job_message($base,$i,"$gantt_name does not exist, skipped");
                            OAR::IO::set_job_scheduler_info($base,$i,"$gantt_name does not exist, skipped");
                            next;
                        }
                   } elsif (defined($types->{constraints}) and not exists($constraints->{$types->{constraints}})) {
                       my ($r, $max_constraint_duration) = OAR::Schedulers::Gantt::compute_constraints($types->{constraints}, $job->{start_time}, $SCHEDULER_CONSTRAINTS_ITERATIONS, "[$SCHEDULER_NAME] [$i]");
                       $constraints->{$types->{constraints}} = $r;
                       # Job cannot be scheduler if job duration does not fit in any constraint
                       #if ($duration < $max_constraint_duration) {
                       #    my $message = "job duration cannot fit in constraints. Skipped";
                       #    oar_debug("[$SCHEDULER_NAME] [$i] $message\n");
                       #    OAR::IO::set_job_message($base,$i,$message);
                       #    OAR::IO::set_job_scheduler_info($base,$i,$message);
                       #    next;
                       #}
                    }
                    if (defined($types->{container})){ # A container job cannot be placeholder or allowed or timesharing. 
                        oar_debug("[$SCHEDULER_NAME] [$i] job is ($gantt_name,,,) and is a container\n");
                        # nothing more to do, Gantt for container will be created once the job is scheduled, below.
                    } else {
                        ($gantt_name, $placeholder_name, $allowed_name, $timesharing_name, $timesharing_user) =
                            OAR::Schedulers::Gantt::manage_gantt_hierarchy($gantt, $job->{job_name}, $job->{job_user}, $types, $constraints, "[$SCHEDULER_NAME] [$i]");
                    }
    
                    my ($dead_resources_vec, @dead_resources) = OAR::IO::get_resource_ids_in_state($base,"Dead");
                    
                    my $job_properties = "\'1\'";
                    if ((defined($job->{properties})) and ($job->{properties} ne "")){
                        $job_properties = $job->{properties};
                    }
    
                    #my $resource_id_used_list_vector = '';
                    my @tree_list;
                    foreach my $m (@{$moldable->[0]}){
                        my $tmp_properties = "\'1\'";
                        if ((defined($m->{property})) and ($m->{property} ne "")){
                            $tmp_properties = $m->{property};
                        }
                        my $tmp_tree = OAR::IO::get_possible_wanted_resources($base_ro,$alive_resources_vector,undef,\@dead_resources,"$job_properties AND $tmp_properties", $m->{resources}, $SCHEDULER_RESOURCE_ORDER);
                        $tmp_tree = OAR::Schedulers::ResourceTree::delete_tree_nodes_with_not_enough_resources($tmp_tree);
                        push(@tree_list, $tmp_tree);
                    }
                    oar_debug("[$SCHEDULER_NAME] [$i] find_first_hole in gantt ($gantt_name,$allowed_name,$timesharing_name,$timesharing_user) with a timeout of $RESERVATION_VALIDATION_TIMEOUT\n");
                    my @hole = OAR::Schedulers::Gantt::find_first_hole(
                        $gantt->{$gantt_name}->{$allowed_name}->{$timesharing_name}->{$timesharing_user},
                        $job->{start_time},
                        $duration + $SCHEDULER_JOB_SECURITY_TIME,
                        \@tree_list,
                        $RESERVATION_VALIDATION_TIMEOUT,
                        $queue_name,
                        $job->{project},
                        \@type_list,
                        $job->{job_user},
                        $quotas,
                        $quota_accounting_data,
                        $Only_default_type_resource_vec
                        );
                    # Free memory
                    foreach my $t (@tree_list){
                        OAR::Schedulers::ResourceTree::destroy($t);
                    }
                    if ($hole[0] == $job->{start_time}){
                        # The reservation can be scheduled
                        oar_warn("[$SCHEDULER_NAME] [$i] advance reservation is validated\n");
                        my @resources;
                        my $res_vec = '';
                        foreach my $t (@{$hole[2]}){
                            $res_vec |= $t->[1];
                            push(@resources, @{$t->[2]});
                            OAR::Schedulers::ResourceTree::destroy($t->[0]);
                        }
    
                        # Create gantt for the new container
                        if (defined($types->{container})){
                            OAR::Schedulers::Gantt::manage_gantt_for_container($gantt, $types->{container}, $i, $job->{start_time}, $duration + $SCHEDULER_JOB_SECURITY_TIME, $res_vec, $Max_resources, $All_resource_list_vec, $SCHEDULER_GANTT_HOLE_MINIMUM_TIME, "[$SCHEDULER_NAME] [$i]");
                        }
            
                        #Fill all other gantts
                        OAR::Schedulers::Gantt::fill_gantt_hierarchy($gantt, $job->{start_time}, $duration + $SCHEDULER_JOB_SECURITY_TIME, $res_vec, $gantt_name, $placeholder_name, $timesharing_name, $timesharing_user, "[$SCHEDULER_NAME] [$i]"); 
                        OAR::Schedulers::Quotas::update_accounting_counters(
                            $quota_accounting_data,
                            unpack("%32b*",$res_vec & $Only_default_type_resource_vec),
                            $job->{start_time},
                            $duration,
                            $job->{queue_name},
                            $job->{project},
                            \@type_list,
                            $job->{job_user}
                        );
    
                        # Update database
                        push(@resources, @Resources_to_always_add);
                        oar_debug("[$SCHEDULER_NAME] [$i] add job in database\n");
                        OAR::IO::add_gantt_scheduled_jobs($base,$moldable->[2],$job->{start_time},\@resources);
                        OAR::IO::set_job_state($base, $job->{job_id}, "toAckReservation");
                    }else{           
                        oar_warn("[$SCHEDULER_NAME] [$i] advance reservation cannot be validated, not enough resources\n");
                        OAR::IO::set_job_state($base, $job->{job_id}, "toError");
                        if ($hole[0] == OAR::Schedulers::Gantt::get_infinity_value()){
                            OAR::IO::set_job_message($base, $job->{job_id}, "This reservation cannot run");
                        }else{
                            OAR::IO::set_job_message($base, $job->{job_id}, "This reservation could run at ".OAR::IO::local_to_sql($hole[0]));
                        }
                    }
                }
                OAR::IO::set_job_resa_state($base, $job->{job_id}, "Scheduled");
            }
            
            oar_debug("[$SCHEDULER_NAME] Queue $queue_name: end processing of new reservations\n");
        }
    }else{
        oar_debug("[$SCHEDULER_NAME] Queue $queue_name: no job\n");
    }
}

if ($exit_code == 0){
    if (check_jobs_to_kill() == 1){
        # We must kill besteffort jobs
        OAR::Tools::notify_tcp_socket($SERVER_HOSTNAME,$SERVER_PORT,"ChState");
        $exit_code = 2;
    }elsif (check_jobs_to_launch() == 1){
        $exit_code = 0;
    }
}

#Update visu gantt tables
OAR::IO::update_gantt_visualization($base); 
OAR::IO::disconnect($base_ro);

# Manage dynamic node feature
my $flagHulot=0;

if ((is_conf("SCHEDULER_NODE_MANAGER_SLEEP_CMD") 
          or (get_conf("ENERGY_SAVING_INTERNAL") eq "yes" and is_conf("ENERGY_SAVING_NODE_MANAGER_SLEEP_CMD")))
          and is_conf("SCHEDULER_NODE_MANAGER_SLEEP_TIME") and is_conf("SCHEDULER_NODE_MANAGER_IDLE_TIME")){

    # Look at nodes that are unused for a duration
    my $SCHEDULER_NODE_MANAGER_IDLE_TIME = get_conf("SCHEDULER_NODE_MANAGER_IDLE_TIME");
    my $SCHEDULER_NODE_MANAGER_SLEEP_TIME = get_conf("SCHEDULER_NODE_MANAGER_SLEEP_TIME");

    my %nodes = OAR::IO::search_idle_nodes($base, $current_time_sec);
    my $tmp_time = $current_time_sec - $SCHEDULER_NODE_MANAGER_IDLE_TIME;
    my @node_halt;
    foreach my $n (keys(%nodes)){
        if ($nodes{$n} < $tmp_time){
            # Search if the node has enough time to sleep
            my $tmp = OAR::IO::get_next_job_date_on_node($base,$n);
            if (!defined($tmp) or ($tmp - $SCHEDULER_NODE_MANAGER_SLEEP_TIME > $current_time_sec)){
                # Search if node has not been woken up recently
                my $wakeup_date = OAR::IO::get_last_wake_up_date_of_node($base,$n);
                if (!defined($wakeup_date) or ($wakeup_date < $tmp_time)){
                    push(@node_halt, $n);
                }
            }
        }
    }

    if ($#node_halt >= 0){
        oar_debug("[$SCHEDULER_NAME] Powering off some nodes (energy saving): @node_halt\n");
        # Using the built-in energy saving module to shut down nodes
        if (get_conf_with_default_param("ENERGY_SAVING_INTERNAL", "no") eq "yes") {
            if (OAR::Modules::Hulot::halt_nodes(\@node_halt) ) {
                oar_error("[$SCHEDULER_NAME] Error: communication problem with the energy saving module (Hulot)\n");
            }
            $flagHulot=1;
        }
        # Not using the built-in energy saving module to shut down nodes
        else {
            my $SCHEDULER_NODE_MANAGER_SLEEP_CMD = get_conf("SCHEDULER_NODE_MANAGER_SLEEP_CMD");
            if (! defined(OAR::Tools::fork_and_feed_stdin($SCHEDULER_NODE_MANAGER_SLEEP_CMD, $SCHEDULER_TIMEOUT, \@node_halt))){
                oar_error("[$SCHEDULER_NAME] Error: command $SCHEDULER_NODE_MANAGER_SLEEP_CMD timeouted (${SCHEDULER_TIMEOUT}s) while trying to poweroff some nodes\n");
            }
        }
    }
}

if (is_conf("SCHEDULER_NODE_MANAGER_WAKE_UP_CMD") or (get_conf("ENERGY_SAVING_INTERNAL") eq "yes" and is_conf("ENERGY_SAVING_NODE_MANAGER_WAKE_UP_CMD"))){
    # Get nodes which the scheduler wants to schedule jobs to, but which are in the Absent state, to wake them up.
    my $wakeup_time = get_conf_with_default_param("SCHEDULER_NODE_MANAGER_WAKEUP_TIME", 1);
    my @nodes = OAR::IO::get_gantt_hostname_to_wake_up($base, $current_time_sec, $wakeup_time);

    if ($#nodes >= 0){
        oar_debug("[$SCHEDULER_NAME] Waking up some nodes: @nodes\n");
        # Using the built-in energy saving module to wake up nodes
        if (get_conf_with_default_param("ENERGY_SAVING_INTERNAL", "no") eq "yes") {
            if (OAR::Modules::Hulot::wake_up_nodes(\@nodes) ) {
                oar_error("[$SCHEDULER_NAME] Error: Communication problem with the energy saving module (Hulot)\n");
            }
						$flagHulot=1;
        }
        # Not using the built-in energy saving module to wake up nodes
        else {
            my $SCHEDULER_NODE_MANAGER_WAKE_UP_CMD = get_conf("SCHEDULER_NODE_MANAGER_WAKE_UP_CMD");
            if (! defined(OAR::Tools::fork_and_feed_stdin($SCHEDULER_NODE_MANAGER_WAKE_UP_CMD, $SCHEDULER_TIMEOUT, \@nodes))){
                oar_error("[$SCHEDULER_NAME] Error: command $SCHEDULER_NODE_MANAGER_WAKE_UP_CMD timeouted (${SCHEDULER_TIMEOUT}s) while trying to wake up some nodes\n");
            }
        }
    }
}

# Send CHECK signal to Hulot if needed
if(!$flagHulot and (get_conf_with_default_param("ENERGY_SAVING_INTERNAL", "no") eq "yes")){
    if (OAR::Modules::Hulot::check() ) {
        oar_error("[$SCHEDULER_NAME] Error: communication problem with the energy saving module (Hulot)\n");
    }
}

# Search jobs to resume
foreach my $j (OAR::IO::get_jobs_in_state($base, "Resuming")){
    my @other_jobs = OAR::IO::get_jobs_on_resuming_job_resources($base,$j->{job_id});
    # TODO : look for timesharing other jobs. What do we do?????
    if ($#other_jobs < 0){
        # We can resume the job
        oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] Resuming job\n");
        my $jobtypes = OAR::IO::get_job_types_hash($base,$j->{job_id});
        if (defined($jobtypes->{noop})){
            oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] call job resume action (noop job)\n");
            OAR::IO::resume_job_action($base,$j->{job_id});
        }else{
            ###############
            # RESUME PART #
            ###############
            my $skip = 0;
            if (defined($JUST_BEFORE_RESUME_EXEC_FILE)){
                # Launch admin script
                my $script_error = 0;
                eval {
                    $SIG{ALRM} = sub { die "alarm\n" };
                    alarm($SUSPEND_RESUME_SCRIPT_TIMEOUT);
                    oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] Running post suspend script: `$JUST_BEFORE_RESUME_EXEC_FILE $j->{job_id}'\n");
                    $script_error = system("$JUST_BEFORE_RESUME_EXEC_FILE script $j->{job_id}");
                    oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] `$JUST_BEFORE_RESUME_EXEC_FILE $j->{job_id}' terminated\n");
                    alarm(0);
                };
                if( $@ || ($script_error != 0)){
                    my $str = "[$SCHEDULER_NAME] [$j->{job_id}] suspend script error: $@; return code = $script_error\n";
                    oar_error($str);
                    OAR::IO::add_new_event($base,"RESUME_SCRIPT_ERROR",$j->{job_id},$str);
                    OAR::IO::frag_job($base,$j->{job_id});
                    OAR::Tools::notify_tcp_socket($SERVER_HOSTNAME,$SERVER_PORT,"Qdel");
                    $skip = 1;
                }
            }

            if (defined($CPUSET_PATH) and $CPUSET_PATH ne "" and $skip == 0){
                my $cpuset_name = OAR::IO::get_job_cpuset_name($base, $j->{job_id});
                my $cpuset_nodes = OAR::IO::get_cpuset_values_for_a_moldable_job($base,$CPUSET_FIELD,$j->{assigned_moldable_job});
                my $suspend_data_hash = {
                    name => $cpuset_name,
                    job_id => $j->{job_id},
                    oarexec_pid_file => OAR::Tools::get_oar_pid_file_name($j->{job_id}),
                };
                if (defined($cpuset_nodes)){
                    $SUSPEND_RESUME_FILE = "$ENV{OARDIR}/$SUSPEND_RESUME_FILE" if ($SUSPEND_RESUME_FILE !~ /^\//);
                    my ($tag,@bad) = OAR::Tools::manage_remote_commands([keys(%{$cpuset_nodes})],$suspend_data_hash,$SUSPEND_RESUME_FILE,"resume",$OPENSSH_CMD,$TAKTUK_CMD,$base);
                    if ($tag == 0){
                        my $str = "[$SCHEDULER_NAME] [$j->{job_id}] bad suspend/resume file: $SUSPEND_RESUME_FILE\n";
                        oar_error($str);
                        OAR::IO::add_new_event($base, "SUSPEND_RESUME_MANAGER_FILE", $j->{job_id}, $str);
                    }else{
                       if (($#bad < 0)){
                            oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] call job resume action\n");
                            OAR::IO::resume_job_action($base,$j->{job_id});
                       }else{
                            my $str = "[$SCHEDULER_NAME] [$j->{job_id}] suspend/resume has errors on nodes: @bad\n";
                            oar_error($str);
                            OAR::IO::add_new_event_with_host($base,"RESUME_ERROR",$j->{job_id},$str,\@bad);
                            OAR::IO::frag_job($base,$j->{job_id});
                            # A Leon must be run
                            $exit_code = 2;
                        }
                    }
                }
            }
            #####################
            # RESUME PART, END  #
            #####################
        }
    }
}

# Notify oarsub -I when they will be launched
foreach my $j (OAR::IO::get_gantt_waiting_interactive_prediction_date($base)){
    my ($addr,$port) = split(/:/,$j->{info_type});
    my $new_start_prediction = OAR::IO::local_to_sql($j->{start_time});
    oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] notifying user of the start prediction: $new_start_prediction (".$j->{message}.")\n");
    OAR::Tools::notify_tcp_socket($addr,$port,"[$initial_time{sql}] start prediction: $new_start_prediction (".$j->{message}.")");
}

# Run the decisions
## Treate "toError" jobs
oar_debug("[$SCHEDULER_NAME] Handle jobs in the toError state\n");
foreach my $j (OAR::IO::get_jobs_in_state($base,"toError")){
    my ($addr,$port) = split(/:/,$j->{info_type});
    if (($j->{job_type} eq "INTERACTIVE") or
        (($j->{job_type} eq "PASSIVE") and
         ($j->{reservation} eq "Scheduled"))){
        oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] notifying oarsub that job is in error; jobInfo=$j->{info_type}\n");
        if ((defined(OAR::Tools::notify_tcp_socket($addr,$port,"$j->{message}"))) or
            (defined(OAR::Tools::notify_tcp_socket($addr,$port,"BAD JOB")))){
            oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] cannot open connection to oarsub client\n");
        }
    }
    oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] set job state to Error\n");
    OAR::IO::set_job_state($base, $j->{job_id}, "Error");
}
## Treate toAckReservation jobs
oar_debug("[$SCHEDULER_NAME] Handle jobs in the toAckReservation state\n");
foreach my $j (OAR::IO::get_jobs_in_state($base,"toAckReservation")){
    my ($addr,$port) = split(/:/,$j->{info_type});
    my $err = OAR::Tools::notify_tcp_socket($addr,$port,"GOOD RESERVATION");
    if (defined($err)){
        oar_warn("[$SCHEDULER_NAME] [$j->{job_id}] fragging job because I could not notify oarsub for the reservation ($err)\n");
        OAR::IO::add_new_event($base,"CANNOT_NOTIFY_OARSUB",$j->{job_id},"[$SCHEDULER_NAME] Can not notify oarsub for the job $j->{job_id} ($err)");
        $base->begin_work();
        OAR::IO::frag_job($base,$j->{job_id});
        $base->commit();
        $exit_code = 2;
    }else{
        oar_debug("[$SCHEDULER_NAME] [$j->{job_id}] reservation is OK and oarsub is notified; jobInfo=$j->{info_type}\n");
        OAR::IO::set_job_state($base,$j->{job_id} , "Waiting");
        if ($j->{start_time} - 1 <= $current_time_sec){
            $exit_code = 1 if ($exit_code == 0);
        }
    }
}
## Treate toLaunch jobs
foreach my $j (OAR::IO::get_jobs_in_state($base,"toLaunch")){
    notify_to_run_job($base, $j->{job_id});
}

OAR::IO::disconnect($base);
oar_debug("[$SCHEDULER_NAME] End of Meta Scheduler\n");

exit($exit_code);
